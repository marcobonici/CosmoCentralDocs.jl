var documenterSearchIndex = {"docs":
[{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"using Plots; gr()\nPlots.reset_defaults()\nusing PlotThemes\nusing CosmoCentral\nusing LaTeXStrings\nusing BenchmarkTools\ndefault(palette = palette(:tab10))\n\n\nw0waCDMCosmology = CosmoCentral.Flatw0waCDMCosmology()\n\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=8, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n\nMultipolesArrayTemp = CosmoCentral.LogSpaced(10.,5000., 101)\nMultipolesArray = zeros(length(MultipolesArrayTemp)-1)\n#MultipolesWidths = vcat(CosmoCentral.Difference(MultipolesArrayTemp), ones(2000))\nMultipolesWidths = CosmoCentral.Difference(MultipolesArrayTemp)\nfor i in 1:length(MultipolesWidths)\n    MultipolesArray[i] = (MultipolesArrayTemp[i+1]+MultipolesArrayTemp[i])/2\nend\n\npath = joinpath(pwd(),\"..\",\"..\",\"test\",\"p_mm\")\nPowerSpectrum, BackgroundQuantities, CosmologicalGrid =\nCosmoCentral.ReadPowerSpectrumBackground(path, MultipolesArray, MultipolesWidths)\nCosmoCentral.ExtractGrowthFactor!(BackgroundQuantities, PowerSpectrum)\n\nCosmoCentral.ComputeLimberArray!(CosmologicalGrid, BackgroundQuantities)\nCosmoCentral.InterpolatePowerSpectrumLimberGrid!(CosmologicalGrid, BackgroundQuantities, PowerSpectrum, CosmoCentral.BSplineCubic())\n\n\nAnalitycalDensity = CosmoCentral.AnalitycalDensity()\nCosmoCentral.NormalizeAnalitycalDensity!(AnalitycalDensity)\n\n#instantiate the instrument response and compute the convolved density\nInstrumentResponse = CosmoCentral.InstrumentResponse()\nConvolvedDensity = CosmoCentral.ConvolvedDensity(DensityGridArray = ones(10,\nlength(CosmologicalGrid.ZArray)))\nCosmoCentral.NormalizeConvolvedDensity!(ConvolvedDensity, AnalitycalDensity,\nInstrumentResponse, CosmologicalGrid)\nCosmoCentral.ComputeConvolvedDensityGrid!(CosmologicalGrid, ConvolvedDensity,\nAnalitycalDensity, InstrumentResponse)\n\nPiecewiseBias = CosmoCentral.PiecewiseBias()\nGCWeightFunction = CosmoCentral.GCWeightFunction(WeightFunctionArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))\nCosmoCentral.ComputeBiasGrid!(CosmologicalGrid, GCWeightFunction, ConvolvedDensity)\nCosmoCentral.ComputeWeightFunctionGrid!(GCWeightFunction, ConvolvedDensity, CosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\n\nWLWeightFunction = CosmoCentral.WLWeightFunction(WeightFunctionArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)), LensingEfficiencyArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))\nCosmoCentral.ComputeLensingEfficiencyGrid!(\n    WLWeightFunction, ConvolvedDensity,\n    CosmologicalGrid,\n    BackgroundQuantities,\n    w0waCDMCosmology, CosmoCentral.CustomLensingEfficiency())\nCosmoCentral.ComputeWeightFunctionGrid!(WLWeightFunction, ConvolvedDensity, CosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\n\nCosmoCentral.ComputeIntrinsicAlignmentGrid!(CosmologicalGrid, WLWeightFunction, ConvolvedDensity, BackgroundQuantities, w0waCDMCosmology)\nCosmoCentral.ComputeWeightFunctionGrid!(WLWeightFunction, ConvolvedDensity, CosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\n\nCℓGG = CosmoCentral.Cℓ(CℓArray = zeros(length(CosmologicalGrid.ℓBinCenters), length(WLWeightFunction.WeightFunctionArray[:, 1]), length(WLWeightFunction.WeightFunctionArray[:, 1])))\nCosmoCentral.ComputeCℓ!(CℓGG, GCWeightFunction, GCWeightFunction, BackgroundQuantities, w0waCDMCosmology, CosmologicalGrid, PowerSpectrum, CosmoCentral.CustomSimpson())\n\nCℓGL = CosmoCentral.Cℓ(CℓArray = zeros(length(CosmologicalGrid.ℓBinCenters), length(WLWeightFunction.WeightFunctionArray[:, 1]), length(WLWeightFunction.WeightFunctionArray[:, 1])))\nCosmoCentral.ComputeCℓ!(CℓGL, GCWeightFunction, WLWeightFunction, BackgroundQuantities, w0waCDMCosmology, CosmologicalGrid, PowerSpectrum, CosmoCentral.CustomSimpson())","category":"page"},{"location":"AngularCoefficients/#Angular-Coefficients","page":"Angular Coefficients","title":"Angular Coefficients","text":"","category":"section"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"Central quantities are the Angular Coefficients C_ell. Actually we implement only the Limber approximation to evaluate the C_ell, according to:","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"C_i j^AB(ell)=fraccH_0 int_z_min ^z_max  mathrmd z fracW_i^A(z) W_j^B(z)E(z) r^2(z) P_delta deltaleft(fracell+1  2r(z) zright)","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"CosmoCentral.Cℓ\nCosmoCentral.∂Cℓ\nCosmoCentral.ComputeCℓ!(Cℓ::CosmoCentral.AbstractCℓ,\nWeightFunctionA::CosmoCentral.AbstractWeightFunction,\nWeightFunctionB::CosmoCentral.AbstractWeightFunction,\nBackgroundQuantities::CosmoCentral.BackgroundQuantities, ::CosmoCentral.w0waCDMCosmology,\nCosmologicalGrid::CosmoCentral.AbstractCosmologicalGrid,\nPowerSpectrum::CosmoCentral.AbstractPowerSpectrum,\n::CosmoCentral.NumericalIntegrationSimpson)\nCosmoCentral.ComputeCℓ!(Cℓ::CosmoCentral.AbstractCℓ,\nWeightFunctionA::CosmoCentral.AbstractWeightFunction,\nWeightFunctionB::CosmoCentral.AbstractWeightFunction,\nBackgroundQuantities::CosmoCentral.BackgroundQuantities, ::CosmoCentral.w0waCDMCosmology,\nCosmologicalGrid::CosmoCentral.AbstractCosmologicalGrid,\nPowerSpectrum::CosmoCentral.AbstractPowerSpectrum, ::CosmoCentral.CustomSimpson)","category":"page"},{"location":"AngularCoefficients/#CosmoCentral.Cℓ","page":"Angular Coefficients","title":"CosmoCentral.Cℓ","text":"Cℓ(CℓArray::AbstractArray{Float64, 3})\n\nThis struct contains the array with the Angular Coefficients.\n\n\n\n\n\n","category":"type"},{"location":"AngularCoefficients/#CosmoCentral.∂Cℓ","page":"Angular Coefficients","title":"CosmoCentral.∂Cℓ","text":"∂Cℓ(∂CℓArray::AbstractArray{Float64, 3})\n\nThis struct contains the array with the derivatives of the Angular Coefficients.\n\n\n\n\n\n","category":"type"},{"location":"AngularCoefficients/#CosmoCentral.ComputeCℓ!-Tuple{CosmoCentral.AbstractCℓ, CosmoCentral.AbstractWeightFunction, CosmoCentral.AbstractWeightFunction, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology, CosmoCentral.AbstractCosmologicalGrid, CosmoCentral.AbstractPowerSpectrum, CosmoCentral.NumericalIntegrationSimpson}","page":"Angular Coefficients","title":"CosmoCentral.ComputeCℓ!","text":"ComputeCℓ!(Cℓ::AbstractCℓ, WeightFunctionA::AbstractWeightFunction,\nWeightFunctionB::AbstractWeightFunction, BackgroundQuantities::BackgroundQuantities,\n::AbstractCosmology, CosmologicalGrid::AbstractCosmologicalGrid,\nPowerSpectrum::AbstractPowerSpectrum, ::NumericalIntegrationSimpson)\n\nThis function evaluates the Angular Coefficients for all tomographic bins and multipole values. In order to evaluate the numerical integrals, it is employed the Simpson numerical method from NumericalIntegration.jl . This is not the fastest method available, but can be used as a benchmark to check consistency.\n\n\n\n\n\n","category":"method"},{"location":"AngularCoefficients/#CosmoCentral.ComputeCℓ!-Tuple{CosmoCentral.AbstractCℓ, CosmoCentral.AbstractWeightFunction, CosmoCentral.AbstractWeightFunction, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology, CosmoCentral.AbstractCosmologicalGrid, CosmoCentral.AbstractPowerSpectrum, CosmoCentral.CustomSimpson}","page":"Angular Coefficients","title":"CosmoCentral.ComputeCℓ!","text":"ComputeCℓ!(Cℓ::AbstractCℓ, WeightFunctionA::AbstractWeightFunction,\nWeightFunctionB::AbstractWeightFunction,\nBackgroundQuantities::AbstractBackgroundQuantities,\n::AbstractCosmology, CosmologicalGrid::AbstractCosmologicalGrid,\nPowerSpectrum::AbstractPowerSpectrum, ::CustomSimpson)\n\nThis function evaluates the Angular Coefficients for all tomographic bins and multipole values. In order to evaluate the numerical integrals, it has been implemented the Simpson rule. The computation is accelerated by LoopVectorization.jl .\n\n\n\n\n\n","category":"method"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"Here we show how to compute and plot the  C_ell's for Weak Lensing.","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"CℓLL = CosmoCentral.Cℓ(CℓArray = zeros(length(CosmologicalGrid.ℓBinCenters),\nlength(WLWeightFunction.WeightFunctionArray[:, 1]),\nlength(WLWeightFunction.WeightFunctionArray[:, 1])))\nCosmoCentral.ComputeCℓ!(CℓLL, WLWeightFunction, WLWeightFunction, BackgroundQuantities,\nw0waCDMCosmology, CosmologicalGrid, PowerSpectrum, CosmoCentral.CustomSimpson())\n\nx = CosmologicalGrid.ℓBinCenters\np = Plots.plot(xlabel=L\"\\ell\", ylabel=L\"\\ell(\\ell+1)C_{ii}^{LL}\",\n    title=\"Weak Lensing\", legend=:bottomright)\nfor i in 1:10\n    y =\n    CℓLL.CℓArray[:,i,i] .* CosmologicalGrid.ℓBinCenters .*(CosmologicalGrid.ℓBinCenters .+1)\nPlots.plot!(p, x, y, labels=(L\"i=%$i\"),  linewidth=3, xaxis=:log, yaxis=:log)\nend\np","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"Following the same procedure it is possible to evaluate the Galaxy Clustering C_ell's...","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"x = CosmologicalGrid.ℓBinCenters\np = Plots.plot(xlabel=L\"\\ell\", ylabel=L\"\\ell(\\ell+1)C_{ii}^{GG}\",\n    title=\"Galaxy Clustering\", legend=:bottomright)\nfor i in 1:10\n    y =\n    CℓGG.CℓArray[:,i,i] .* CosmologicalGrid.ℓBinCenters .* (CosmologicalGrid.ℓBinCenters .+1)\nPlots.plot!(p, x, y, labels=(L\"i=%$i\"),  linewidth=3, xaxis=:log, yaxis=:log)\nend\np","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"...and the C_ell's of the Cross-Correlation. Due to the contributions of the Intrinsic Alignment, some of the C_ell's are negative. Since we use the loglog scale, we plot the absolute value of the angular coefficients; the negative C_ell's are indicated with dashed lines","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"x = CosmologicalGrid.ℓBinCenters\np = Plots.plot(xlabel=L\"\\ell\", ylabel=L\"\\ell(\\ell+1)|C_{ii}^{GL}|\",\n    title= \"Galaxy-Galaxy Lensing\", legend=:bottomright)\nfor i in 1:10\n    y = CℓGL.CℓArray[:,i,i] .* CosmologicalGrid.ℓBinCenters .*\n    (CosmologicalGrid.ℓBinCenters .+1)\n    if any(x->x<=0, y)\n        Plots.plot!(p, x, -y, labels=(L\"i=%$i\"),  linewidth=3, xaxis=:log, yaxis=:log,\n        linestyle = :dash)\n    else\n        Plots.plot!(p, x, y, labels=(L\"i=%$i\"),  linewidth=3, xaxis=:log, yaxis=:log)\n    end\nend\np","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"Finally, the computation of the C_ell's is quite fast. In particular, here we benchmark their evaluation with 100 different ell's value. ","category":"page"},{"location":"AngularCoefficients/","page":"Angular Coefficients","title":"Angular Coefficients","text":"@benchmark CosmoCentral.ComputeCℓ!(CℓGL, GCWeightFunction, WLWeightFunction, BackgroundQuantities, w0waCDMCosmology, CosmologicalGrid, PowerSpectrum, CosmoCentral.CustomSimpson())","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"using Plots; gr()\nPlots.reset_defaults()\nusing CosmoCentral\nusing LaTeXStrings\nusing BenchmarkTools\n\nw0waCDMCosmology = CosmoCentral.Flatw0waCDMCosmology()\nCosmologicalGrid  = CosmoCentral.CosmologicalGrid(\nZArray=Array(LinRange(0.001, 4.0, 500)))\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=12, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n\n\nCosmologicalGrid = CosmoCentral.CosmologicalGrid(ZArray = LinRange(0.001, 2.5, 500))\nConvolvedDensity = CosmoCentral.ConvolvedDensity(DensityGridArray =\n        ones(10, length(CosmologicalGrid.ZArray)))","category":"page"},{"location":"BackgroundUniverse/#Background-Universe","page":"Background Universe","title":"Background Universe","text":"","category":"section"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"Some of the most basics quantities in cosmology are the Hubble factor H(z) and the comoving distance chi(z). In this section are presented the functions which evaluate them.","category":"page"},{"location":"BackgroundUniverse/#Hubble-factor","page":"Background Universe","title":"Hubble factor","text":"","category":"section"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"CosmoCentral.ComputeAdimensionalHubbleFactor\nCosmoCentral.ComputeHubbleFactor","category":"page"},{"location":"BackgroundUniverse/#CosmoCentral.ComputeAdimensionalHubbleFactor","page":"Background Universe","title":"CosmoCentral.ComputeAdimensionalHubbleFactor","text":"ComputeAdimensionalHubbleFactor(z::Float64, w0waCDMCosmology::w0waCDMCosmology)\n\nThis function, given the value of the cosmological parameters, evaluate the Adimensional Hubble Factor for w_0 w_aCDM cosmologies. The analitycal expression is given by:\n\nE(z)=sqrtOmega_M(1+z)^3+Omega_R(1+z)^4+\nOmega_DE(1+z)^3(1+w_0+w_a)exp(-3w_a fracz1+z)+Omega_k(1+z)^2\n\nwarning: Warning\nThis expression is valid only for the CPL parameterization of the Dark Energy Equation of State.\n\n\n\n\n\n","category":"function"},{"location":"BackgroundUniverse/#CosmoCentral.ComputeHubbleFactor","page":"Background Universe","title":"CosmoCentral.ComputeHubbleFactor","text":"ComputeHubbleFactor(z::Float64, AbstractCosmology::AbstractCosmology)\n\nThis function, given the value of the cosmological parameters, evaluate the Hubble Factor for w_0 w_aCDM cosmologies, whose expression is given by\n\nH(z)=H_0sqrtOmega_M(1+z)^3+Omega_R(1+z)^4+\nOmega_DE(1+z)^3(1+w_0+w_a)exp(-3w_a fracz1+z)+Omega_k(1+z)^2\n\n\n\n\n\n","category":"function"},{"location":"BackgroundUniverse/#Distances","page":"Background Universe","title":"Distances","text":"","category":"section"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"CosmoCentral.Computeχ","category":"page"},{"location":"BackgroundUniverse/#CosmoCentral.Computeχ","page":"Background Universe","title":"CosmoCentral.Computeχ","text":"Computeχ(z::Float64, AbstractCosmology::AbstractCosmology)\n\nThis function, given the value of the cosmological parameters, evaluate the Comoving Distance χ. It is evaluated as:\n\nchi(z)=fraccH_0int_0^z fracdzE(z)\n\n\n\n\n\n","category":"function"},{"location":"BackgroundUniverse/#BackgroundQuantities","page":"Background Universe","title":"BackgroundQuantities","text":"","category":"section"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"In order to store them in a convenient way, we use a structure, CosmoCentral.BackgroundQuantities, which contains all the background quantities","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"CosmoCentral.BackgroundQuantities","category":"page"},{"location":"BackgroundUniverse/#CosmoCentral.BackgroundQuantities","page":"Background Universe","title":"CosmoCentral.BackgroundQuantities","text":"BackgroundQuantities(HZArray::Vector{Float64}, χZArray::Vector{Float64}),\nDZArray::Vector{Float64}\n\nThis struct contains the arrays with the values of the Hubble parameter H(z) and the comoving distance chi(z).\n\n\n\n\n\n","category":"type"},{"location":"BackgroundUniverse/#Utils","page":"Background Universe","title":"Utils","text":"","category":"section"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"A useful function, regarding the background quantities, is CosmoCentral.ComputeBackgroundQuantitiesGrid!. It computes the background quantities over the redshift grid.","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"CosmoCentral.ComputeBackgroundQuantitiesGrid!","category":"page"},{"location":"BackgroundUniverse/#CosmoCentral.ComputeBackgroundQuantitiesGrid!","page":"Background Universe","title":"CosmoCentral.ComputeBackgroundQuantitiesGrid!","text":"ComputeBackgroundQuantitiesOverGrid(CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities,\nAbstractCosmology::AbstractCosmology)\n\nThis function evaluate the Hubble factor and the comoving distance over the CosmologicalGrid.\n\n\n\n\n\n","category":"function"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"Here we show how to calculate H(z) and chi(z) over the redshift grid, then we plot  them","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"\n#instantiate background quantities and compute them\nBackgroundQuantities = CosmoCentral.BackgroundQuantities(HZArray=\nzeros(length(CosmologicalGrid.ZArray)),\nχZArray=zeros(length(CosmologicalGrid.ZArray)))\nCosmoCentral.ComputeBackgroundQuantitiesGrid!(CosmologicalGrid,\nBackgroundQuantities, w0waCDMCosmology)\n\npH = plot(CosmologicalGrid.ZArray, BackgroundQuantities.HZArray./ w0waCDMCosmology.H0,\nylabel = L\"E(z)\")\npχ = plot(CosmologicalGrid.ZArray, BackgroundQuantities.χZArray,\nylabel = L\"\\chi(z)\\, \\left[\\mathrm{Mpc}\\right]\", xlabel= L\"z\")\nplot(pH, pχ, layout = (2, 1), legend = false)","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"We also want to show that this code is fast. In this particular example, we are going to compute H(z) and chi(z) on a redshift grid of 500 points","category":"page"},{"location":"BackgroundUniverse/","page":"Background Universe","title":"Background Universe","text":"BackgroundQuantities = CosmoCentral.BackgroundQuantities(HZArray=\nzeros(length(CosmologicalGrid.ZArray)),\nχZArray=zeros(length(CosmologicalGrid.ZArray)))\n@benchmark CosmoCentral.ComputeBackgroundQuantitiesGrid!(CosmologicalGrid,\nBackgroundQuantities, w0waCDMCosmology)","category":"page"},{"location":"MathUtils/#Math-Utils","page":"Math Utils","title":"Math Utils","text":"","category":"section"},{"location":"MathUtils/","page":"Math Utils","title":"Math Utils","text":"In order to perform some calculations, we use some custom function, which are listed here.","category":"page"},{"location":"MathUtils/","page":"Math Utils","title":"Math Utils","text":"CosmoCentral.LogSpaced\nCosmoCentral.BinSearch\nCosmoCentral.CustomRegression\nCosmoCentral.CWindow\nCosmoCentral.DuplicationMatrix","category":"page"},{"location":"MathUtils/#CosmoCentral.LogSpaced","page":"Math Utils","title":"CosmoCentral.LogSpaced","text":"LogSpaced(min::Float64, max::Float64, n::Int64)\n\nThis function evaluates n points, logarithmically spaced between     min and max.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#CosmoCentral.BinSearch","page":"Math Utils","title":"CosmoCentral.BinSearch","text":"BinSearch(x::Float64, Array::Vector{Float64})\n\nGiven a value z and an Array, determines the couple of array elements where z lies and returns the index corresponding to the first value.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#CosmoCentral.CustomRegression","page":"Math Utils","title":"CosmoCentral.CustomRegression","text":"CustomRegression(x::Vector{Float64}, y::Vector{Float64})\n\nGiven two arrays x and y, performs the linear regression and returns the coefficients c and m of the fitted line.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#CosmoCentral.CWindow","page":"Math Utils","title":"CosmoCentral.CWindow","text":"CWindow(N::Vector{Float64}, NCut::Int64)\n\nThis function evaluates the smoothing window function as defined in Eq. (C.1) of this paper.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#CosmoCentral.DuplicationMatrix","page":"Math Utils","title":"CosmoCentral.DuplicationMatrix","text":"DuplicationMatrix(n::Int)\n\nDuplication matrix boldsymbolD_n.\n\n\n\n\n\n","category":"function"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"using Plots; gr()\nPlots.reset_defaults()\nusing CosmoCentral\nusing LaTeXStrings\nusing BenchmarkTools\n\nw0waCDMCosmology = CosmoCentral.Flatw0waCDMCosmology()\nCosmologicalGrid  = CosmoCentral.CosmologicalGrid(\nZArray=Array(LinRange(0.001, 4.0, 500)))\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=12, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n\nMultipolesArrayTemp = CosmoCentral.LogSpaced(10.,5000., 101)\nMultipolesArray = zeros(length(MultipolesArrayTemp)-1)\n#MultipolesWidths = vcat(CosmoCentral.Difference(MultipolesArrayTemp), ones(2000))\nMultipolesWidths = CosmoCentral.Difference(MultipolesArrayTemp)\nfor i in 1:length(MultipolesWidths)\n    MultipolesArray[i] = (MultipolesArrayTemp[i+1]+MultipolesArrayTemp[i])/2\nend\n\npath = joinpath(pwd(),\"..\",\"..\",\"test\",\"p_mm\")\nPowerSpectrum, BackgroundQuantities, CosmologicalGrid =\nCosmoCentral.ReadPowerSpectrumBackground(path, MultipolesArray, MultipolesWidths)\nCosmoCentral.ExtractGrowthFactor!(BackgroundQuantities, PowerSpectrum)\n\nCosmoCentral.ComputeLimberArray!(CosmologicalGrid, BackgroundQuantities)","category":"page"},{"location":"BoltzmannSolver/#BoltzmannSolver","page":"Boltzmann Solver","title":"BoltzmannSolver","text":"","category":"section"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"One of the core components of CosmoCentral are the Boltzmann solvers, codes developed by the community that solve the coupled Einstein-Boltzmann equations and used to evaluate the Matter Power Spectrum. Currently, the Boltzmann codes implemented in CosmoCentral are:","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"CLASS","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"We plan to include other Boltzmann solvers in the future.","category":"page"},{"location":"BoltzmannSolver/#Power-Spectrum","page":"Boltzmann Solver","title":"Power Spectrum","text":"","category":"section"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"CosmoCentral.PowerSpectrum\nCosmoCentral.ComputeLimberArray!\nCosmoCentral.InterpolatePowerSpectrumLimberGrid!\nCosmoCentral.InterpolationMethod","category":"page"},{"location":"BoltzmannSolver/#CosmoCentral.PowerSpectrum","page":"Boltzmann Solver","title":"CosmoCentral.PowerSpectrum","text":"PowerSpectrum()\n\nThis struct contains the array with the Linear and Nonlinear Power Spectrum evaluated on the k-z grid and the interpolated Nonlinear Power Spectrum on Limber k-z grid.\n\n\n\n\n\n","category":"type"},{"location":"BoltzmannSolver/#CosmoCentral.ComputeLimberArray!","page":"Boltzmann Solver","title":"CosmoCentral.ComputeLimberArray!","text":"ComputeLimberArray!(CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities)\n\nThis function compute the Limber grid. In the Limber approximation, k and z are related by the following relation:\n\nk_ell(z)=fracell+12r(z)\n\n\n\n\n\n","category":"function"},{"location":"BoltzmannSolver/#CosmoCentral.InterpolatePowerSpectrumLimberGrid!","page":"Boltzmann Solver","title":"CosmoCentral.InterpolatePowerSpectrumLimberGrid!","text":"InterpolatePowerSpectrumLimberGrid!(CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities, PowerSpectrum::PowerSpectrum,\n::InterpolationMethod)\n\nThis function interpolates the Power Spectrum on the k-z grid and evaluates it on the Limber grid.\n\n\n\n\n\n","category":"function"},{"location":"BoltzmannSolver/#CosmoCentral.InterpolationMethod","page":"Boltzmann Solver","title":"CosmoCentral.InterpolationMethod","text":"InterpolationMethod\n\nThis type is used to specify the method to interpolate the Power Spectrum; actually are included:\n\nDierckx.jl, the Julia wrapper for the Fortran library Dierckx\nGriddedLinear, from Interpolations.jl\nBSpliceCubic (recommended, for its speed and accuracy), from Interpolations.jl\n\n\n\n\n\n","category":"type"},{"location":"BoltzmannSolver/#classy","page":"Boltzmann Solver","title":"classy","text":"","category":"section"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"classy is the Python wrapper for CLASS.","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"CosmoCentral.classyParams\nCosmoCentral.Initializeclassy\nCosmoCentral.EvaluatePowerSpectrum!","category":"page"},{"location":"BoltzmannSolver/#CosmoCentral.classyParams","page":"Boltzmann Solver","title":"CosmoCentral.classyParams","text":"classyParams(classyParamsDict::Dict)\n\nThis struct contains the dictionary with the classy parameters. For a detalied explanation of the parameters, please refer to the CLASS website\n\n\n\n\n\n","category":"type"},{"location":"BoltzmannSolver/#CosmoCentral.Initializeclassy","page":"Boltzmann Solver","title":"CosmoCentral.Initializeclassy","text":"Initializeclassy(cosmo::w0waCDMCosmology)\n\nThis function, given a w0waCDMCosmology, returns the classyParams correctly initialized.\n\n\n\n\n\n","category":"function"},{"location":"BoltzmannSolver/#CosmoCentral.EvaluatePowerSpectrum!","page":"Boltzmann Solver","title":"CosmoCentral.EvaluatePowerSpectrum!","text":"EvaluatePowerSpectrum!(classyParams:: classyParams, cosmogrid::CosmologicalGrid,\npmm::PowerSpectrum)\n\nThis function runs classy to evaluate the Matter Power Spectrum over the k-z grid specified in CosmologicalGrid\n\n\n\n\n\n","category":"function"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"For instance, here we show the linear and nonlinear P_deltadelta(kz), evaluated by CLASS, for a the reference cosmology.","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"p = plot(CosmologicalGrid.KArray, PowerSpectrum.PowerSpectrumLinArray[:,1],\nylabel = L\"P(k)\\,\\left[\\mathrm{Mpc}^{3}\\right]\", xlabel = L\"k\\,\\left[\\mathrm{Mpc}^{-1}\\right]\",\nxaxis=:log, yaxis=:log, label = L\"\\mathrm{Linear}\", xlims = (1e-5,10), ylims = (1,1e5))\nplot!(p, CosmologicalGrid.KArray, PowerSpectrum.PowerSpectrumNonlinArray[:,1],\nxaxis=:log, yaxis=:log, label = L\"\\mathrm{Nonlinear}\")","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"When performing forecasts, P_delta delta(kz) can be valuated once and stored (we  provide a precomputed set of spectra here), so their computational impact is reduced. However, when evaluating C_ell's, there is a not negligible impact of P_ deltadelta(kz) interpolation and evaluation on the Limber  k-grid.","category":"page"},{"location":"BoltzmannSolver/","page":"Boltzmann Solver","title":"Boltzmann Solver","text":"@benchmark CosmoCentral.InterpolatePowerSpectrumLimberGrid!(CosmologicalGrid,\nBackgroundQuantities, PowerSpectrum, CosmoCentral.BSplineCubic())","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"using Plots; gr()\nPlots.reset_defaults()\nusing CosmoCentral\nusing LaTeXStrings\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=12, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n\n\nCosmologicalGrid = CosmoCentral.CosmologicalGrid(ZArray = LinRange(0.001, 2.5, 500))\nConvolvedDensity = CosmoCentral.ConvolvedDensity(DensityGridArray =\n        ones(10, length(CosmologicalGrid.ZArray)))","category":"page"},{"location":"Bias/#Bias","page":"Bias","title":"Bias","text":"","category":"section"},{"location":"Bias/","page":"Bias","title":"Bias","text":"One of the most important ingredients of the Galaxy Clustering Weight function is the Galaxy Bias, that is, the statistical relation between the distribution of galaxies and matter","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"delta_g(boldsymbolx)=b delta(boldsymbolx)","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"In this page are listed the Bias Model we have implemented.","category":"page"},{"location":"Bias/#Piecewise-Bias","page":"Bias","title":"Piecewise Bias","text":"","category":"section"},{"location":"Bias/","page":"Bias","title":"Bias","text":"The Piecewise Bias model is taken from the official Euclid forecast","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"b(z)= sqrt1+barz","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"where barz is the redshift value in the center of the tomographic bin where the redshift z lies. The PiecewiseBias is plotted here.","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"GCWeightFunction = CosmoCentral.GCWeightFunction(WeightFunctionArray=\nzeros(length(ConvolvedDensity.DensityGridArray[1,:]), length(CosmologicalGrid.ZArray)),\nBiasKind = CosmoCentral.PiecewiseBias())\nCosmoCentral.ComputeBiasGrid!(CosmologicalGrid, GCWeightFunction, ConvolvedDensity)\nx = CosmologicalGrid.ZArray; y = GCWeightFunction.BiasArray[1, :];\nplot(x, y, ylabel = L\"\\mathrm{Bias}\\,(z)\", xlabel=L\"z\")","category":"page"},{"location":"Bias/#Euclid-Flagsip-Bias","page":"Bias","title":"Euclid Flagsip Bias","text":"","category":"section"},{"location":"Bias/","page":"Bias","title":"Bias","text":"This model, obtained from the Flagship Euclid simulation is taken from Tutusaus et al 2021","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"b(z)=A+fracB1+exp -(z-D) C","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"GCWeightFunction = CosmoCentral.GCWeightFunction(WeightFunctionArray=\n        zeros(length(ConvolvedDensity.DensityGridArray[1,:]),\n        length(CosmologicalGrid.ZArray)), BiasKind = CosmoCentral.EuclidBias())\nCosmoCentral.ComputeBiasGrid!(CosmologicalGrid, GCWeightFunction, ConvolvedDensity)\nx = CosmologicalGrid.ZArray; y = GCWeightFunction.BiasArray[1, :];\nplot(x, y, ylabel = L\"\\mathrm{Bias}\\,(z)\", xlabel= L\"z\")","category":"page"},{"location":"Bias/","page":"Bias","title":"Bias","text":"CosmoCentral.ComputeBias\nCosmoCentral.ComputeBiasGrid!","category":"page"},{"location":"Bias/#CosmoCentral.ComputeBias","page":"Bias","title":"CosmoCentral.ComputeBias","text":"ComputeBias(z::Float64, ::PiecewiseBias,\nConvolvedDensity::AbstractConvolvedDensity)\n\nThis function evaluate the piecewise bias, given by sqrt1+z, for a given redshift.\n\n\n\n\n\n","category":"function"},{"location":"Bias/#CosmoCentral.ComputeBiasGrid!","page":"Bias","title":"CosmoCentral.ComputeBiasGrid!","text":"ComputeBiasGrid!(cosmogrid::CosmologicalGrid,\ngcWeightFunction::GCWeightFunction, Bias::AbstractBias,\nConvolvedDensity::AbstractConvolvedDensity)\n\nThis function evaluate the bias, over the cosmological redshift grid.\n\n\n\n\n\n","category":"function"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"using Plots; gr()\nPlots.reset_defaults()\nusing CosmoCentral","category":"page"},{"location":"Covariance/#Covariance-Matrix","page":"Covariance Matrix","title":"Covariance Matrix","text":"","category":"section"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"In order to evaluate the Fisher Matrix CosmoCentral.Fisherαβ, a Covariance Matrix is required. Here we show the two Gaussian Covariance Matrix we have implemented, in the Field and Estimator Approach.","category":"page"},{"location":"Covariance/#Field-approach","page":"Covariance Matrix","title":"Field approach","text":"","category":"section"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"The Covariance Matrix in the Field approach is evaluated by the following method","category":"page"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"CosmoCentral.aₗₘCovariance\nCosmoCentral.InstantiateEvaluateCovariance(cℓ::CosmoCentral.AbstractCℓ,\nConvDens::CosmoCentral.AbstractConvolvedDensity, cosmogrid::CosmoCentral.CosmologicalGrid,\nProbeA::String, ProbeB::String)","category":"page"},{"location":"Covariance/#CosmoCentral.aₗₘCovariance","page":"Covariance Matrix","title":"CosmoCentral.aₗₘCovariance","text":"aₗₘCovariance()\n\nThis struct contains the Covariance in the field perspective, i.e. when the observables are the  a_ell m's.\n\n\n\n\n\n","category":"type"},{"location":"Covariance/#CosmoCentral.InstantiateEvaluateCovariance-Tuple{CosmoCentral.AbstractCℓ, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.CosmologicalGrid, String, String}","page":"Covariance Matrix","title":"CosmoCentral.InstantiateEvaluateCovariance","text":"InstantiateEvaluateCovariance(cℓ::AbstractCℓ, ConvDens::AbstractConvolvedDensity,\ncosmogrid::CosmologicalGrid, ProbeA::String, ProbeB::String)\n\nThis function evaluates and returns the aₗₘCovariance, according to the following formula:\n\nSigma_i j^mathrmAB(ell)=sqrtfrac2(2 ell+1) Delta ell\nf_mathrmskyleft(C_i j^mathrmAB(ell)+N_i j^mathrmAB(ell)\nright)\n\nwhere mathrmA and mathrmB are the probes, mathrmi and mathrmj are the tomographic bins, ell and Deltaell are respectively the central value and width of the considered multipole bin, f_mathrmsky is the sky fraction covered by the field considered, N_i j^mathrmAB is the noise matrix.\n\n\n\n\n\n","category":"method"},{"location":"Covariance/#Estimator-approach","page":"Covariance Matrix","title":"Estimator approach","text":"","category":"section"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"The Fisher Matrix in the Estimator approach is evaluated by the following method","category":"page"},{"location":"Covariance/","page":"Covariance Matrix","title":"Covariance Matrix","text":"CosmoCentral.CℓCovariance\nCosmoCentral.InstantiateEvaluateCovariance(Covaₗₘ::CosmoCentral.aₗₘCovariance)","category":"page"},{"location":"Covariance/#CosmoCentral.CℓCovariance","page":"Covariance Matrix","title":"CosmoCentral.CℓCovariance","text":"CℓCovariance()\n\nThis struct contains the Covariance in the estimator perspective, i.e. when the observables are the C_ell's.\n\n\n\n\n\n","category":"type"},{"location":"Covariance/#CosmoCentral.InstantiateEvaluateCovariance-Tuple{CosmoCentral.aₗₘCovariance}","page":"Covariance Matrix","title":"CosmoCentral.InstantiateEvaluateCovariance","text":"InstantiateEvaluateCovariance(Covaₗₘ::aₗₘCovariance)\n\nThis function evaluates and returns the CℓCovariance, using the following formula:\n\nboldsymbolXi(ell)= left(boldsymbolD_n^Tleft( left(boldsymbolSigma(ell)right)^-1 otimes\nleft(boldsymbolSigma(ell)right)^-1right) boldsymbolD_nright)^-1\n\nwhere boldsymbolD_n is the DuplicationMatrix.\n\n\n\n\n\n","category":"method"},{"location":"Cosmology/#Cosmology","page":"Cosmology","title":"Cosmology","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"In this section we show the structures which specify the cosmology and the value of the parameters. In this moment we support only the w_0 w_aCDM cosmology, although we plan to include support to other cosmologies.","category":"page"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"CosmoCentral.w0waCDMCosmology","category":"page"},{"location":"Cosmology/#CosmoCentral.w0waCDMCosmology","page":"Cosmology","title":"CosmoCentral.w0waCDMCosmology","text":"w0waCDMCosmology(w0::Float64 = -1, wa::Float64 = 0, ΩM::Float64 = 0.32,\nΩB::Float64  = 0.05, ΩDE::Float64 = 0.68, Ωk::Float64  = 0.,\nΩr::Float64  = 0., ns::Float64  = 0.96, Mν::Float64  = 0.06,\nσ8::Float64  = 0.816, H0::Float64  = 67.)\n\nThis struct contains the value of the cosmological parameters for w_0 w_aCDM cosmologies:\n\nw_0 and w_a, the parameters in the CPL parameterization\nOmega_M, Omega_B, Omega_DE, Omega_R, and Omega_k the density parameters for respectively  matter, baryons, Dark Energy, radiation, curvature\nn_s, the scalar spectral index\nM_nu, the sum of the neutrino mass eigenstates in eV\nsigma_8, the amplitude of the scalar fluctuations\nH_0, the value of the Hubble paramater\n\n\n\n\n\n","category":"type"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"In the remainder of this documentation, we will show how to use CosmoCentral.jl and we will plot several quantities. The assumed values for the cosmological parameters are:","category":"page"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"Omega_M = 0.32\nOmega_B = 0.05\nOmega_k = 0\nn_s = 0.96\nsigma_8 = 0.816\nh = 0.67\nM_nu = 0.06 eV\nw_0 = -1\nw_a = 0","category":"page"},{"location":"Cosmology/#Cosmological-Grid","page":"Cosmology","title":"Cosmological Grid","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"Another import quantity is the cosmological grid, the structure which specifies the grids used to compute the quantities in our calculations.","category":"page"},{"location":"Cosmology/","page":"Cosmology","title":"Cosmology","text":"CosmoCentral.CosmologicalGrid","category":"page"},{"location":"Cosmology/#CosmoCentral.CosmologicalGrid","page":"Cosmology","title":"CosmoCentral.CosmologicalGrid","text":"CosmologicalGrid{T} <: AbstractCosmologicalGrid{T}\nZArray::AbstractArray{T} = LinRange(0.001, 2.5, 300)\nKArray::AbstractArray{T} = LogSpaced(1e-5, 50., 1000)\nℓBinCenters::AbstractArray{T} = LinRange(10., 3000., 2991)\nℓBinWidths::AbstractArray{T} = LinRange(10., 3000., 2991)\nKLimberArray::AbstractArray{T,2} = zeros(length(ℓBinCenters),\nlength(ZArray))\nKBeyondLimberArray::AbstractArray{T,2} = zeros(100, 1000)\n\nThis struct contains several grids:\n\nZArray and KArray, the grids for the PowerSpectrum calculations\nℓBinCenters, the ell grid for the C_ell's calculations\nℓBinWidths, used when computing the covariance matrix\nKLimberArray, the k grid to evaluate the C_ell's in the Limber approximation\nKBeyondLimberArray, the k grid to evaluate the C_ell's without the Limber approximation\n\n\n\n\n\n","category":"type"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"using Plots; gr()\nPlots.reset_defaults()\nusing PlotThemes\nusing CosmoCentral\nusing LaTeXStrings\nusing BenchmarkTools\ndefault(palette = palette(:tab10))\n\nw0waCDMCosmology = CosmoCentral.Flatw0waCDMCosmology()\n\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=12, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n\nMultipolesArrayTemp = CosmoCentral.LogSpaced(10.,5000., 101)\nMultipolesArray = zeros(length(MultipolesArrayTemp)-1)\n#MultipolesWidths = vcat(CosmoCentral.Difference(MultipolesArrayTemp), ones(2000))\nMultipolesWidths = CosmoCentral.Difference(MultipolesArrayTemp)\nfor i in 1:length(MultipolesWidths)\n    MultipolesArray[i] = (MultipolesArrayTemp[i+1]+MultipolesArrayTemp[i])/2\nend\n\npath = joinpath(pwd(),\"..\",\"..\",\"test\",\"p_mm\")\nPowerSpectrum, BackgroundQuantities, CosmologicalGrid =\nCosmoCentral.ReadPowerSpectrumBackground(path, MultipolesArray, MultipolesWidths)\nCosmoCentral.ExtractGrowthFactor!(BackgroundQuantities, PowerSpectrum)\n\n\nAnalitycalDensity = CosmoCentral.AnalitycalDensity()\nCosmoCentral.NormalizeAnalitycalDensity!(AnalitycalDensity)\n\n#instantiate the instrument response and compute the convolved density\nInstrumentResponse = CosmoCentral.InstrumentResponse()\nConvolvedDensity = CosmoCentral.ConvolvedDensity(DensityGridArray = ones(10,\nlength(CosmologicalGrid.ZArray)))\nCosmoCentral.NormalizeConvolvedDensity!(ConvolvedDensity, AnalitycalDensity,\nInstrumentResponse, CosmologicalGrid)\nCosmoCentral.ComputeConvolvedDensityGrid!(CosmologicalGrid, ConvolvedDensity,\nAnalitycalDensity, InstrumentResponse)\nPiecewiseBias = CosmoCentral.PiecewiseBias()\nGCWeightFunction = CosmoCentral.GCWeightFunction(WeightFunctionArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))\nWLWeightFunction = CosmoCentral.WLWeightFunction(WeightFunctionArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)), LensingEfficiencyArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))","category":"page"},{"location":"WeightFunction/#Weight-Function","page":"Weight Functions","title":"Weight Function","text":"","category":"section"},{"location":"WeightFunction/#Galaxy-Clustering","page":"Weight Functions","title":"Galaxy Clustering","text":"","category":"section"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"The expression of the Galaxy Clustering Weight Function is given by:","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"W_i^mathrmG(z)=b_i(z) n_i(z) fracH(z)c","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"CosmoCentral.GCWeightFunction\nCosmoCentral.ComputeWeightFunction(z::Float64, i::Int64,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    AnalitycalDensity::CosmoCentral.AnalitycalDensity,\n    InstrumentResponse::CosmoCentral.InstrumentResponse,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology,\n    GCWeightFunction::CosmoCentral.GCWeightFunction)\nCosmoCentral.ComputeWeightFunctionGrid!(\n    GCWeightFunction::CosmoCentral.GCWeightFunction,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    BackgroundQuantities::CosmoCentral.BackgroundQuantities,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology)","category":"page"},{"location":"WeightFunction/#CosmoCentral.GCWeightFunction","page":"Weight Functions","title":"CosmoCentral.GCWeightFunction","text":"GCWeightFunction()\n\nThis struct contains the array with the Galaxy Bias and Galaxy Clustering Weight Function values for all tomographic bins and redshift values in the CosmologicalGrid.\n\n\n\n\n\n","category":"type"},{"location":"WeightFunction/#CosmoCentral.ComputeWeightFunction-Tuple{Float64, Int64, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.AnalitycalDensity, CosmoCentral.InstrumentResponse, CosmoCentral.w0waCDMCosmology, CosmoCentral.GCWeightFunction}","page":"Weight Functions","title":"CosmoCentral.ComputeWeightFunction","text":"ComputeWeightFunction(z::Float64, i::Int64, ConvolvedDensity::AbstractConvolvedDensity,\nAnalitycalDensity::AnalitycalDensity, InstrumentResponse::InstrumentResponse,\nw0waCDMCosmology::w0waCDMCosmology, GCWeightFunction::GCWeightFunction)\n\nThis function returns the Galaxy Clustering Weight function for a given redshift z and tomographic bin i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/#CosmoCentral.ComputeWeightFunctionGrid!-Tuple{CosmoCentral.GCWeightFunction, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.CosmologicalGrid, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology}","page":"Weight Functions","title":"CosmoCentral.ComputeWeightFunctionGrid!","text":"ComputeWeightFunctionGrid!(GCWeightFunction::GCWeightFunction,\nConvolvedDensity::AbstractConvolvedDensity, CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities, Cosmology::AbstractCosmology)\n\nThis function evaluates the Galaxy Clustering Weight Function over the z grid and for all tomographic bins i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"For instance, here we plot the Galaxy Clustering weight function with a piecewise bias","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"PiecewiseBias = CosmoCentral.PiecewiseBias()\nGCWeightFunction = CosmoCentral.GCWeightFunction(WeightFunctionArray =\nzeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))\n\nCosmoCentral.ComputeBiasGrid!(CosmologicalGrid, GCWeightFunction, ConvolvedDensity)\nCosmoCentral.ComputeWeightFunctionGrid!(GCWeightFunction, ConvolvedDensity,\nCosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\np = Plots.plot(xlabel=L\"z\", ylabel=L\"W_i^g(z)\\,\\left[\\mathrm{Mpc}^{-1}\\right]\")\nfor i in 1:10\nPlots.plot!(p, CosmologicalGrid.ZArray, GCWeightFunction.WeightFunctionArray[i,:],\n    labels=(L\"i=%$i\"),  linewidth=3)\nend\np","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"Computing b(z) and W_i^g(z) is quite fast","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"@benchmark CosmoCentral.ComputeBiasGrid!(CosmologicalGrid, GCWeightFunction, ConvolvedDensity)","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"@benchmark CosmoCentral.ComputeWeightFunctionGrid!(GCWeightFunction, ConvolvedDensity,\nCosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)","category":"page"},{"location":"WeightFunction/#Weak-Lensing","page":"Weight Functions","title":"Weak Lensing","text":"","category":"section"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"The expression of the Weak Lensing Weight Function is given by:","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"W_i^gamma(z)=frac32left(fracH_0cright)^2 Omega_mathrmm 0(1+z) r(z) widetildeW_i(z)","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"where widetildeW_i(z) is the Lensing Efficiency, whose expression is given by","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"widetildeW_i(z)=int_z^z_max  mathrmd z^prime n_ileft(z^primeright)left1-fractilder(z)tilderleft(z^primeright)right","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"CosmoCentral.WLWeightFunction\nCosmoCentral.ComputeWeightFunction(z::Float64, i::Int64,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    AnalitycalDensity::CosmoCentral.AnalitycalDensity,\n    InstrumentResponse::CosmoCentral.InstrumentResponse,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    wlWeightFunction::CosmoCentral.WLWeightFunction)\nCosmoCentral.ComputeWeightFunctionGrid!(\n    wlWeightFunction::CosmoCentral.WLWeightFunction,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    BackgroundQuantities::CosmoCentral.BackgroundQuantities,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology)\nCosmoCentral.ComputeLensingEfficiency(z::Float64, i::Int64,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    AnalitycalDensity::CosmoCentral.AnalitycalDensity,\n    InstrumentResponse::CosmoCentral.InstrumentResponse,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    wlWeightFunction::CosmoCentral.WLWeightFunction)\nCosmoCentral.ComputeLensingEfficiencyGrid!(wlWeightFunction::CosmoCentral.WLWeightFunction,\n    AnalitycalDensity::CosmoCentral.AnalitycalDensity,\n    InstrumentResponse::CosmoCentral.InstrumentResponse,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    BackgroundQuantities::CosmoCentral.BackgroundQuantities,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology,\n    ::CosmoCentral.StandardLensingEfficiency)\nCosmoCentral.ComputeLensingEfficiencyGrid!(wlWeightFunction::CosmoCentral.WLWeightFunction,\n    ConvolvedDensity::CosmoCentral.AbstractConvolvedDensity,\n    CosmologicalGrid::CosmoCentral.CosmologicalGrid,\n    BackgroundQuantities::CosmoCentral.BackgroundQuantities,\n    w0waCDMCosmology::CosmoCentral.w0waCDMCosmology, ::CosmoCentral.CustomLensingEfficiency)","category":"page"},{"location":"WeightFunction/#CosmoCentral.WLWeightFunction","page":"Weight Functions","title":"CosmoCentral.WLWeightFunction","text":"WLWeightFunction()\n\nThis struct contains the array with the Lensing Efficiency and Weak Lensing Weight Function values for all tomographic bins and redshift values in the CosmologicalGrid\n\n\n\n\n\n","category":"type"},{"location":"WeightFunction/#CosmoCentral.ComputeWeightFunction-Tuple{Float64, Int64, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.AnalitycalDensity, CosmoCentral.InstrumentResponse, CosmoCentral.w0waCDMCosmology, CosmoCentral.CosmologicalGrid, CosmoCentral.WLWeightFunction}","page":"Weight Functions","title":"CosmoCentral.ComputeWeightFunction","text":"ComputeWeightFunction(z::Float64, i::Int64,ConvolvedDensity::AbstractConvolvedDensity,\nAnalitycalDensity::AnalitycalDensity, InstrumentResponse::InstrumentResponse,\nCosmology::AbstractCosmology, CosmologicalGrid::CosmologicalGrid,\nLensingFunction::WLWeightFunction)\n\nThis function returns the Weak Lensing Weight Function, for a given redshift z and tomographic bin i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/#CosmoCentral.ComputeWeightFunctionGrid!-Tuple{CosmoCentral.WLWeightFunction, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.CosmologicalGrid, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology}","page":"Weight Functions","title":"CosmoCentral.ComputeWeightFunctionGrid!","text":"ComputeWeightFunctionGrid!(LensingFunction::WLWeightFunction,\nConvolvedDensity::AbstractConvolvedDensity, CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities, Cosmology::AbstractCosmology)\n\nThis function evaluates the Weak Lensing Weight Function over the z grid and for all tomographic bins i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/#CosmoCentral.ComputeLensingEfficiency-Tuple{Float64, Int64, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.AnalitycalDensity, CosmoCentral.InstrumentResponse, CosmoCentral.w0waCDMCosmology, CosmoCentral.CosmologicalGrid, CosmoCentral.WLWeightFunction}","page":"Weight Functions","title":"CosmoCentral.ComputeLensingEfficiency","text":"ComputeLensingEfficiency(z::Float64, i::Int64,\nConvolvedDensity::AbstractConvolvedDensity, AnalitycalDensity::AnalitycalDensity,\nInstrumentResponse::InstrumentResponse, w0waCDMCosmology::w0waCDMCosmology,\nCosmologicalGrid::CosmologicalGrid, ::WLWeightFunction)\n\nThis function returns the Lensing efficiency, for a given redshift z and tomographic bin i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/#CosmoCentral.ComputeLensingEfficiencyGrid!-Tuple{CosmoCentral.WLWeightFunction, CosmoCentral.AnalitycalDensity, CosmoCentral.InstrumentResponse, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.CosmologicalGrid, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology, CosmoCentral.StandardLensingEfficiency}","page":"Weight Functions","title":"CosmoCentral.ComputeLensingEfficiencyGrid!","text":"ComputeLensingEfficiencyGrid!(LensingFunction::WLWeightFunction,\nAnalitycalDensity::AnalitycalDensity, InstrumentResponse::InstrumentResponse,\nConvolvedDensity::AbstractConvolvedDensity, CosmologicalGrid::CosmologicalGrid,\nBackgroundQuantities::BackgroundQuantities, Cosmology::AbstractCosmology,\n::StandardLensingEfficiency)\n\nThis function evaluates the Lensing Efficiency over the z grid and for all tomographic bins i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/#CosmoCentral.ComputeLensingEfficiencyGrid!-Tuple{CosmoCentral.WLWeightFunction, CosmoCentral.AbstractConvolvedDensity, CosmoCentral.CosmologicalGrid, CosmoCentral.BackgroundQuantities, CosmoCentral.w0waCDMCosmology, CosmoCentral.CustomLensingEfficiency}","page":"Weight Functions","title":"CosmoCentral.ComputeLensingEfficiencyGrid!","text":"ComputeLensingEfficiencyGrid!(\nLensingFunction::WLWeightFunction, ConvolvedDensity::AbstractConvolvedDensity,\nCosmologicalGrid::CosmologicalGrid, BackgroundQuantities::BackgroundQuantities,\nw0waCDMCosmology::w0waCDMCosmology, ::CustomLensingEfficiency)\n\nThis function evaluates the Lensing Efficiency over the z grid and for all tomographic bins i.\n\n\n\n\n\n","category":"method"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"Here we plot the Weak Lensing weight function. In particular, the solid lines are pure shear, while the dashed lines includes the Intrinsic Alignment contribution.","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"WLWeightFunction = CosmoCentral.WLWeightFunction(WeightFunctionArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)), LensingEfficiencyArray = zeros(length(ConvolvedDensity.DensityNormalizationArray), length(CosmologicalGrid.ZArray)))\nCosmoCentral.ComputeLensingEfficiencyGrid!(\n    WLWeightFunction, ConvolvedDensity,\n    CosmologicalGrid,\n    BackgroundQuantities,\n    w0waCDMCosmology, CosmoCentral.CustomLensingEfficiency())\nCosmoCentral.ComputeWeightFunctionGrid!(WLWeightFunction, ConvolvedDensity, CosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\np = Plots.plot(xlabel=L\"z\", ylabel=L\"W_i^\\gamma(z)\\,\\left[\\mathrm{Mpc}^{-1}\\right]\")\nfor i in 1:10\nPlots.plot!(p, CosmologicalGrid.ZArray, WLWeightFunction.WeightFunctionArray[i,:],\n    labels=(L\"i=%$i\"),  linewidth=3)\nend\n\nCosmoCentral.ComputeIntrinsicAlignmentGrid!(CosmologicalGrid, WLWeightFunction, ConvolvedDensity, BackgroundQuantities, w0waCDMCosmology)\nCosmoCentral.ComputeWeightFunctionGrid!(WLWeightFunction, ConvolvedDensity, CosmologicalGrid, BackgroundQuantities, w0waCDMCosmology)\nfor i in 1:10\nPlots.plot!(p, CosmologicalGrid.ZArray, WLWeightFunction.WeightFunctionArray[i,:],\nlinewidth=3, linestyle = :dash)\nend\np","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"Computations related to Weak Lensing are a bit slower, due to the nested integrals inside W_i^gamma(z)","category":"page"},{"location":"WeightFunction/","page":"Weight Functions","title":"Weight Functions","text":"@benchmark CosmoCentral.ComputeLensingEfficiencyGrid!(WLWeightFunction, ConvolvedDensity,\nCosmologicalGrid, BackgroundQuantities, w0waCDMCosmology,\nCosmoCentral.CustomLensingEfficiency())","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"using Plots; gr()\nPlots.reset_defaults()\nusing CosmoCentral\nusing JSON\nusing LaTeXStrings\nusing CairoMakie\nusing Makie\nusing LinearAlgebra\nusing FisherPlot\nrun(`wget https://zenodo.org/record/5270335/files/forecast_pmm.tar.xz\\?download=1`);\nrun(`mv forecast_pmm.tar.xz\\?download\\=1 forecast_pmm.tar.xz`);\nrun(`tar xvf forecast_pmm.tar.xz`);\nrun(`rm -rf forecast_pmm.tar.xz`);\nMultipolesArrayTemp = CosmoCentral.LogSpaced(10.,3000., 101)\nMultipolesArray = zeros(100)\nMultipolesWidths = CosmoCentral.Difference(MultipolesArrayTemp)\nfor i in 1:100\n    MultipolesArray[i] = (MultipolesArrayTemp[i+1]+MultipolesArrayTemp[i])/2\nend\n\nsteps = Array([0.00625, 0.01250, 0.01875, 0.02500, 0.03750, 0.05000, 0.10000])\ncosmogrid = CosmoCentral.CosmologicalGrid(ZArray =\nArray(LinRange(0.001, 4., 500)), KArray = CosmoCentral.LogSpaced(1e-5, 50., 1000),\nℓBinCenters = MultipolesArray, ℓBinWidths = MultipolesWidths)\nProbesDict = JSON.parsefile(pwd()*\"/../../input_files/AngularNew.json\")\nCosmoDict = JSON.parsefile(pwd()*\"/../../input_files/Cosmology.json\")\nForecastContainer = CosmoCentral.InitializeForecastContainer(CosmoDict, ProbesDict,\ncosmogrid, steps)\nCosmoCentral.CreateDirectoriesForecast!(ForecastContainer, pwd()*\"/test_forecast/\")\nPathInputPmm = pwd()*\"/forecast_pmm/PowerSpectrum/\"\nPathOutputCℓ = pwd()*\"/test_forecast/Angular/\"\nPathOutput = pwd()*\"/test_forecast\"\nPathCentralCℓ = pwd()*\"/test_forecast/Angular/dvar_central_step_0/cl\"\nPath∂Cℓ = pwd()*\"/test_forecast/Derivative\"\nCosmoCentral.ForecastCℓ!(ForecastContainer, cosmogrid, PathInputPmm, PathOutputCℓ)\nCosmoCentral.Forecast∂Cℓ!(ForecastContainer, PathOutput, PathOutputCℓ, steps)\nFisherWL = CosmoCentral.ForecastFisherαβ(ForecastContainer ,PathCentralCℓ, Path∂Cℓ,\ncosmogrid, \"Lensing\", \"Test\")\nFisherGC = CosmoCentral.ForecastFisherαβ(ForecastContainer ,PathCentralCℓ, Path∂Cℓ,\ncosmogrid, \"PhotometricClustering\", \"Test\")\nFisherXC_WL_GC = CosmoCentral.ForecastFisherαβ(ForecastContainer ,PathCentralCℓ, Path∂Cℓ,\ncosmogrid, \"Lensing\", \"PhotometricClustering\", \"Test\")\nFisherGCplusWL = CosmoCentral.SumFisher(FisherWL, FisherGC)\nFisherGCNew = CosmoCentral.RearrangeFisherℓ(FisherGC, cosmogrid, 10, 3000)\nCosmoCentral.SelectMatrixAndMarginalize!(FisherGCNew.ParametersList, FisherGCNew)\nFisherGCNewplusWL = CosmoCentral.SumFisher(FisherWL, FisherGCNew)\nFisherXC_WL_GCNew = CosmoCentral.RearrangeFisherℓ(FisherXC_WL_GC, cosmogrid, 10, 3000)\nFisherWL_Add = CosmoCentral.RearrangeFisherℓ(FisherWL, cosmogrid, 3000, 5000)\nFisherFinal = CosmoCentral.SumFisher(FisherWL_Add, FisherXC_WL_GCNew)\n\nBigLaTeXArray = [L\"\\Omega_\\mathrm{M}\", L\"\\Omega_\\mathrm{B}\", L\"H_0\", L\"n_s\", L\"\\sigma_8\", L\"M_\\nu\", L\"w_a\", L\"w_0\"]\npars_list = [\"ΩM\", \"ΩB\", \"H0\", \"ns\", \"σ8\", \"Mν\", \"wa\", \"w0\"]\ncentral_values =[0.32, 0.05, 67., 0.96, 0.816, 0.06, 0., -1.0]\n\nmarg_errs = []\nfor par in pars_list\n    append!(marg_errs, FisherWL.MarginalizedErrors[par])\nend\n\nnoto_sans = \"Computer Modern\"#assetpath(\"/usr/share/fonts/computer_modern\", \"NewCM10-Regular.otf\")\n\ndimticklabel = 50\nsidesquare = 400\nylabelsize = 39\n\nPlotPars = Dict(\"sidesquare\" => sidesquare,\n\"dimticklabel\" => dimticklabel,\n\"parslabelsize\" => 80,\n\"textsize\" => 80,\n\"PPmaxlabelsize\" => 60,\n\"font\" => noto_sans,\n\"xticklabelrotation\" => 45.)\n\nlimits = zeros(8,2)\nticks = zeros(8,2)\nfor i in 1:8\n    limits[i,1] = central_values[i]-3marg_errs[i]*1.3\n    limits[i,2] = central_values[i]+3marg_errs[i]*1.3\n    ticks[i,1] = central_values[i]-3marg_errs[i]\n    ticks[i,2] = central_values[i]+3marg_errs[i]\nend\n\nprobes = [L\"\\mathrm{WL}\", L\"\\mathrm{GC}_\\mathrm{ph}\",\nL\"\\mathrm{WL}\\,+\\,\\mathrm{GC}_\\mathrm{ph}\",\nL\"\\mathrm{WL}\\,+\\,\\mathrm{GC}_\\mathrm{ph}\\,+\\,\\mathrm{XC}\"]\ncolors = [\"deepskyblue3\", \"darkorange1\", \"green\", \"red\"]","category":"page"},{"location":"Fisher/#Fisher-Forecast","page":"Fisher Forecast","title":"Fisher Forecast","text":"","category":"section"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"Fisher Matrices can be used to forecast parameter uncertainties with few computational resources. They are encapsulated in the following struct","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"CosmoCentral.Fisherαβ","category":"page"},{"location":"Fisher/#CosmoCentral.Fisherαβ","page":"Fisher Forecast","title":"CosmoCentral.Fisherαβ","text":"Fisherαβ()\n\nThis struct contains the array with the Fisher Matrix.\n\n\n\n\n\n","category":"type"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"We implement two different approaches to evaluate the Fisher Matrix:","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"A field approach, where we consider the a_ell m to be the observable\nAn estimator approach, where we consider the C_ell's to be the observable","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"If correctly implemented, the two approaches give the same result (Hamimeche & Lewis 2008, Carron 2012).","category":"page"},{"location":"Fisher/#Field-approach","page":"Fisher Forecast","title":"Field approach","text":"","category":"section"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"The Fisher Matrix in the Field approach is evaluated by the following method","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"CosmoCentral.ForecastFisherαβ(PathCentralCℓ::String, Path∂Cℓ::String,\nInputList::Vector{Dict{String, Vector{Any}}},\nCosmologicalGrid::CosmoCentral.CosmologicalGrid)","category":"page"},{"location":"Fisher/#CosmoCentral.ForecastFisherαβ-Tuple{String, String, Vector{Dict{String, Vector{Any}}}, CosmoCentral.CosmologicalGrid}","page":"Fisher Forecast","title":"CosmoCentral.ForecastFisherαβ","text":"ForecastFisherαβ(PathCentralCℓ::String, Path∂Cℓ::String,\nInputList::Vector{Dict{String, Vector{Any}}}, CosmologicalGrid::CosmologicalGrid)\n\nThis function evaluate the Fisher Matrix according to the following formula:\n\nF_alpha beta=sum_ell=ell_min ^ell_max  operatornameTrleft\nboldsymbolSigma(ell)^-1 fracpartial mathbfC(ell)partial \nalphaboldsymbolSigma(ell)^-1 fracpartial mathbfC(ell)partial\nbetaright\n\nwhere alpha and beta are parameters of the Fisher Matrix, ell are the multipoles, Sigma is the Covariance Matrix of the  Field Approach and fracpartial mathbfC(ell)partial alpha is the Matrix of the derivatives of the C_ell wrt parameter alpha.\n\n\n\n\n\n","category":"method"},{"location":"Fisher/#Estimator-approach","page":"Fisher Forecast","title":"Estimator approach","text":"","category":"section"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"The Fisher Matrix in the Estimator approach is evaluated by the following method","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"CosmoCentral.ForecastFisherαβ(PathCentralCℓ::String, Path∂Cℓ::String,\nInputList::Vector{Dict{String, Vector{Any}}},\nCosmologicalGrid::CosmoCentral.CosmologicalGrid, ciccio::String)","category":"page"},{"location":"Fisher/#CosmoCentral.ForecastFisherαβ-Tuple{String, String, Vector{Dict{String, Vector{Any}}}, CosmoCentral.CosmologicalGrid, String}","page":"Fisher Forecast","title":"CosmoCentral.ForecastFisherαβ","text":"ForecastFisherαβ(PathCentralCℓ::String, Path∂Cℓ::String,\nInputList::Vector{Dict{String, Vector{Any}}}, CosmologicalGrid::CosmologicalGrid,\nciccio::String)\n\nThis function evaluate the Fisher Matrix according to the following formula:\n\nF_alpha beta=sum_ell=ell_min ^ell_max  operatornamevecp\nleft(fracpartial mathbfC(ell)partial alpharight)^T\nleft(boldsymbolXi(ell)right)^-1 operatornamevecpleft(fracpartial\nmathbfC(ell) partial betaright)\n\nwhere alpha and beta are parameters of the Fisher Matrix, ell are the multipoles, Xi is the Covariance Matrix of the  Field Approach CℓCovariance and fracpartial mathbfC(ell)partial alpha is the Matrix of the derivatives of the C_ell wrt parameter alpha.\n\n\n\n\n\n","category":"method"},{"location":"Fisher/#Plotting-Fisher-Matrix","page":"Fisher Forecast","title":"Plotting Fisher Matrix","text":"","category":"section"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"Here we show plots for some Fisher Matrices (this code will probably soon released in a separate package).","category":"page"},{"location":"Fisher/","page":"Fisher Forecast","title":"Fisher Forecast","text":"canvas = FisherPlot.PrepareCanvas(BigLaTeXArray, central_values, limits, ticks, probes, colors,\nPlotPars)\nFisherPlot.PaintCorrMattrix!(canvas, central_values,\nCosmoCentral.SelectCorrelationMatrix(FisherWL, pars_list), \"deepskyblue3\")\nFisherPlot.PaintCorrMattrix!(canvas, central_values,\nCosmoCentral.SelectCorrelationMatrix(FisherGCNew, pars_list), \"darkorange1\")\nFisherPlot.PaintCorrMattrix!(canvas, central_values,\nCosmoCentral.SelectCorrelationMatrix(FisherGCNewplusWL, pars_list), \"green\")\nFisherPlot.PaintCorrMattrix!(canvas, central_values,\nCosmoCentral.SelectCorrelationMatrix(FisherFinal, pars_list), \"red\")\ncanvas","category":"page"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"using Plots; gr()\nPlots.reset_defaults()\nusing PlotThemes\nusing CosmoCentral\nusing LaTeXStrings\n\n#instantiate cosmology and grid\nw0waCDMCosmology = CosmoCentral.Flatw0waCDMCosmology()\nCosmologicalGrid  = CosmoCentral.CosmologicalGrid(\nZArray=Array(LinRange(0.001, 4.0, 500)))\n\nplot_font = \"Computer Modern\"\nPlots.default(titlefont = (16, plot_font), fontfamily=plot_font,\n        linewidth=2, framestyle=:box, fg_legend =:black, label=nothing, grid=false,\n        tickfontsize=12, legendfontsize=12, size = (550, 400), labelfontsize = 13,\n        dpi = 200)\n","category":"page"},{"location":"SourceDensity/#Source-Density","page":"Source Density","title":"Source Density","text":"","category":"section"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"In this page are presented the structures and functions used to deal with source densities and are listed here.","category":"page"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"Pages = [\"SourceDensity.md\"]","category":"page"},{"location":"SourceDensity/#Source-Density-2","page":"Source Density","title":"Source Density","text":"","category":"section"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"In the evaluation of Angular Coefficients, central quantities are the source densities. In this section are presented the custom types and function used to deal with the source densities.","category":"page"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"CosmoCentral.AnalitycalDensity\nCosmoCentral.ComputeDensity\nCosmoCentral.NormalizeAnalitycalDensity!","category":"page"},{"location":"SourceDensity/#CosmoCentral.AnalitycalDensity","page":"Source Density","title":"CosmoCentral.AnalitycalDensity","text":"AnalitycalDensity(z0::Float64 = 0.9/sqrt(2.), zmin::Float64 = 0.001,\nzmax::Float64 = 2.5, surfacedensity::Float64 = 30.,\nnormalization::Float64 = 1.)\n\nThis struct contains the parameters of the source galaxy density as given by the official Euclid forecast, whose expression is given by:\n\nn(z)proptoleft(fraczz_0right)^2\nexpleft(-left(fraczz_0right)^-32right)\n\nThe parameters contained in this struct are\n\nz_min and z_max, the minimum and the maximum redshift considered\nz_0, the parameter present in the galaxy distribution\nsurfacedensity , the value of the galaxy source density integrated between z_min and z_max\nnormalization, the value of parameter which multiplies the source dennsity in order to match the correct surface density\n\n\n\n\n\n","category":"type"},{"location":"SourceDensity/#CosmoCentral.ComputeDensity","page":"Source Density","title":"CosmoCentral.ComputeDensity","text":"ComputeDensityFunction(z::Float64, AnalitycalDensity::AnalitycalDensity)\n\nThis function returns the source density for a given redshift z.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/#CosmoCentral.NormalizeAnalitycalDensity!","page":"Source Density","title":"CosmoCentral.NormalizeAnalitycalDensity!","text":"NormalizeAnalitycalDensity!(AnalitycalDensity::AnalitycalDensity)\n\nThis function normalize AnalitycalDensity in order to have the correct value of the surface density once integrated.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/#Convolved-Source-Density","page":"Source Density","title":"Convolved Source Density","text":"","category":"section"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"In real surveys we do not deal with the exact distributions due to errors in the measurement of the source redshifts. The redshift errors are accounted for convolving the source density with a redshift measurement error.","category":"page"},{"location":"SourceDensity/#Intrument-Response","page":"Source Density","title":"Intrument Response","text":"","category":"section"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"CosmoCentral.InstrumentResponse\nCosmoCentral.ComputeInstrumentResponse","category":"page"},{"location":"SourceDensity/#CosmoCentral.InstrumentResponse","page":"Source Density","title":"CosmoCentral.InstrumentResponse","text":"InstrumentResponse(cb::Float64 = 1.0, zb::Float64 = 0.0,\nσb::Float64 = 0.05, co::Float64 = 1.0, zo::Float64 = 0.1,\nσo::Float64 = 0.05, fout::Float64 = 0.1)\n\nWhen we measure the redshift of a galaxy with redshit z, we will measure a redshift z_p with a probability given by the following expression:\n\np(z_pz)  = frac1-f_outsqrt2 pi sigma_b(1+z) exp left(\n-frac12left(fracz-c_b z_b-z_bsigma_b(1+z)right)^2\nright) + fracf_outsqrt2 pi sigma_mathrmo(1+z) exp\nleft(-frac12left(fracz-c_o z_p-z_osigma_o(1+z)\nright)^2right)\n\nThis struct contains all these parameters.\n\n\n\n\n\n","category":"type"},{"location":"SourceDensity/#CosmoCentral.ComputeInstrumentResponse","page":"Source Density","title":"CosmoCentral.ComputeInstrumentResponse","text":"ComputeInstrumentResponse(z::Float64, zp::Float64,\nInstrumentResponse::InstrumentResponse)\n\nThis function computes the probability that we actually measure a redshift z_p if the real redshift is z.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/#Convolved-Source-Density-2","page":"Source Density","title":"Convolved Source Density","text":"","category":"section"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"CosmoCentral.ConvolvedDensity\nCosmoCentral.ComputeConvolvedDensity\nCosmoCentral.NormalizeConvolvedDensity!\nCosmoCentral.ComputeConvolvedDensityGrid!","category":"page"},{"location":"SourceDensity/#CosmoCentral.ConvolvedDensity","page":"Source Density","title":"CosmoCentral.ConvolvedDensity","text":"ConvolvedDensity(AnalitycalDensity::AnalitycalDensity = AnalitycalDensity(),\nInstrumentResponse::InstrumentResponse = InstrumentResponse()\nZBinArray::Vector{Float64} = Array([0.001, 0.418, 0.560, 0.678, 0.789, 0.900, 1.019, 1.155, 1.324, 1.576, 2.50])\nDensityNormalizationArray::Vector{Float64} = ones(length(ZBinArray)-1)\nDensityGridArray::AbstractArray{Float64, 2} = ones(length(ZBinArray)-1, 300))\n\nIn order to take into account the error in the redshift measurement, the source density is convolved with the InstrumentResponse, according to the following equation\n\nn_i(z)=fracint_z_i^-^z_i^+\nmathrmd z_mathrmp n(z) p left(z_mathrmp\nmid zright)int_z_min ^z_max  mathrmd z\nint_z_i^-^z_i^+ mathrmd z_mathrmp n(z) p\nleft(z_mathrmp mid zright)\n\n\n\n\n\n","category":"type"},{"location":"SourceDensity/#CosmoCentral.ComputeConvolvedDensity","page":"Source Density","title":"CosmoCentral.ComputeConvolvedDensity","text":"ComputeConvolvedDensity(z::Float64, i::Int64, ConvolvedDensity::AbstractConvolvedDensity,\nAnalitycalDensity::AnalitycalDensity, InstrumentResponse::InstrumentResponse)\n\nThis function computes the Convolved density function for a single bin at a given redshift z.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/#CosmoCentral.NormalizeConvolvedDensity!","page":"Source Density","title":"CosmoCentral.NormalizeConvolvedDensity!","text":"NormalizeConvolvedDensity!(ConvolvedDensity::AbstractConvolvedDensity,\nAnalitycalDensity::AnalitycalDensity,InstrumentResponse::InstrumentResponse,\nCosmologicalGrid::CosmologicalGrid)\n\nThis function normalizes ConvolvedDensity such that the integrals of the convolved densities are normalized to 1.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/#CosmoCentral.ComputeConvolvedDensityGrid!","page":"Source Density","title":"CosmoCentral.ComputeConvolvedDensityGrid!","text":"ComputeConvolvedDensityGrid!(CosmologicalGrid::CosmologicalGrid,\nConvolvedDensity::AbstractConvolvedDensity, AnalitycalDensity::AnalitycalDensity,\nInstrumentResponse::InstrumentResponse)\n\nThis function computes the convolved density function for all tomographic bins on the z-grid provided by CosmologicalGrid.\n\n\n\n\n\n","category":"function"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"Here we show how to calculate n_g^i(z), then we will plot it","category":"page"},{"location":"SourceDensity/","page":"Source Density","title":"Source Density","text":"\n#instantiate the analytical density and normalize it\nAnalitycalDensity = CosmoCentral.AnalitycalDensity()\nCosmoCentral.NormalizeAnalitycalDensity!(AnalitycalDensity)\n\n#instantiate the instrument response and compute the convolved density\nInstrumentResponse = CosmoCentral.InstrumentResponse()\nConvolvedDensity = CosmoCentral.ConvolvedDensity(DensityGridArray = ones(10,\nlength(CosmologicalGrid.ZArray)))\nCosmoCentral.NormalizeConvolvedDensity!(ConvolvedDensity, AnalitycalDensity,\nInstrumentResponse, CosmologicalGrid)\nCosmoCentral.ComputeConvolvedDensityGrid!(CosmologicalGrid, ConvolvedDensity,\nAnalitycalDensity, InstrumentResponse)\n\np = Plots.plot(xlabel=L\"z\", ylabel=L\"n_i^g(z)\",\n    title=\"Normalized galaxy density\")\nfor i in 1:10\nPlots.plot!(p, CosmologicalGrid.ZArray, ConvolvedDensity.DensityGridArray[i,:],\n    labels=(L\"i=%$i\"),  linewidth=3)\nend\np","category":"page"},{"location":"Derivatives/#Derivatives","page":"Derivatives","title":"Derivatives","text":"","category":"section"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"A central method in Fisher Forecast is the numerical derivatives of observables. However, since the Angular Coefficients are evaluated performing numerical integration of solution of the Einstein-Boltzmann equations, finite-differences methods are quite unstable. Up to now, we have included the following methods","category":"page"},{"location":"Derivatives/","page":"Derivatives","title":"Derivatives","text":"CosmoCentral.SteMDerivative","category":"page"},{"location":"Derivatives/#CosmoCentral.SteMDerivative","page":"Derivatives","title":"CosmoCentral.SteMDerivative","text":"SteMDerivative(x::Vector{Float64}, y::Vector{Float64})\n\nThis function evaluates the numerical derivative according to the SteM algorithm, Camera et al. 2017:\n\na linear regression over x and y is performed\nif the points obtained with the fit are close enough (less than 0.01 relative difference) the linear ansatz is satisfied and the slope gives the derivative\nif the linear ansatz is not satisfied, the external couple of points and the linear regression is performed again till the linear ansatz is satisfied\n\n\n\n\n\n","category":"function"},{"location":"#CosmoCentral.jl","page":"Home","title":"CosmoCentral.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CosmoCentral is a Julia package to perform cosmological calculations. Actually it can evaluate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Background quantities for w_0 w_aCDM cosmologies\nGalaxy redshift densities, with an analitycal in input\nAngular Correlation functions, C_ℓ's, for Galaxy Clustering and Weak Lensing using the Limber approximation\nDerivatives of C_ℓ's with respect to cosmological and nuisance parameters\nFisher Matrices and Marginalized errors","category":"page"},{"location":"","page":"Home","title":"Home","text":"We aim to include also:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Include other effects to the probes considered (e.g. magnification bias, redshift space distortions etc.)\nEvaluation of C_ℓ's beyond Limber approximation (WIP)\nPlot of Fisher Matrix 2D contours (WIP)\nDifferentiable programming, to evaluate partial C_ell's or the Hessian of the likelihood, using automatic differentiation\nNon-Gaussian Covariance contributions","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Marco Bonici, INAF - Institute of Space Astrophysics and Cosmic Physics (IASF), Milano\nCarmelita Carbone, INAF - Institute of Space Astrophysics and Cosmic Physics (IASF), Milano","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the remainder of the documentation, we show how to use CosmoCentral.jl in details. When we will release the first version of CosmoCentral.jl, we will provide some notebooks showing the usage of CosmoCentral.jl.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please make sure to update tests as appropriate.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CosmoCentral is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"}]
}
